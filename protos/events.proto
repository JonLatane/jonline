syntax = "proto3";

package jonline;

import "google/protobuf/timestamp.proto";
import "posts.proto";
import "media.proto";
import "visibility_moderation.proto";
import "users.proto";
import "location.proto";

// Valid GetEventsRequest formats:
// - {[listing_type: PublicEvents]}                  (TODO: get ServerPublic/GlobalPublic events you can see)
// - {listing_type:MyGroupsEvents|FollowingEvents}   (TODO: get events for groups joined or user followed; auth required)
// - {event_id:}                                     (TODO: get single event including preview data)
// - {listing_type: GroupEvents|
//      GroupEventsPendingModeration,
//      group_id:}                                  (TODO: get events/events needing moderation for a group)
// - {author_user_id:, group_id:}                   (TODO: get events by a user for a group)
// - {listing_type: AuthorEvents, author_user_id:}  (TODO: get events by a user)
message GetEventsRequest {
  // Returns the single event with the given ID.
  optional string event_id = 1;
  // Limits results to replies to the given event.
  // optional string replies_to_event_id = 2;
  // Limits results to those by the given author user ID.
  optional string author_user_id = 2;
  optional string group_id = 3;
  optional string event_instance_id = 4;
  optional TimeFilter time_filter = 5;
  EventListingType listing_type = 10;
}

// Time filter that simply works on the starts_at and ends_at fields.
message TimeFilter {
  optional google.protobuf.Timestamp starts_after = 1;
  optional google.protobuf.Timestamp ends_after = 2;
  optional google.protobuf.Timestamp starts_before = 3;
  optional google.protobuf.Timestamp ends_before = 4;
}

enum EventListingType {
  // Gets SERVER_PUBLIC and GLOBAL_PUBLIC events as is sensible.
  // Also usable for getting replies anywhere.
  PUBLIC_EVENTS = 0;
  // Returns events from users the user is following.
  FOLLOWING_EVENTS = 1;
  // Returns events from any group the user is a member of.
  MY_GROUPS_EVENTS = 2;
  // Returns `DIRECT` events that are directly addressed to the user.
  DIRECT_EVENTS = 3;
  EVENTS_PENDING_MODERATION = 4;

  // group_id parameter is required for these.
  GROUP_EVENTS = 10;
  GROUP_EVENTS_PENDING_MODERATION = 11;
}

message GetEventsResponse {
  repeated Event events = 1;
}

// An `Event` is a top-level type used to organize calendar events, RSVPs, and messaging/posting
// about the `Event`. Actual time data lies in its `EventInstances`.
//
// (Eventually, Jonline Events should also support ticketing.)
message Event {
  // Unique ID for the event generated by the Jonline BE.
  string id = 1;
  // The Post containing the underlying data for the event (names). Its `PostContext` should be `EVENT`.
  Post post = 2;
  // Event configuration like whether to allow (anonymous) RSVPs, etc.
  EventInfo info = 3;
  // A list of instances for the Event. *Events will only include all instances if the request is for a single event.*
  repeated EventInstance instances = 4;
}

// To be used for ticketing, RSVPs, etc.
// Stored as JSON in the database.
message EventInfo {
  optional bool allows_rsvps = 1;
  optional bool allows_anonymous_rsvps = 2;
  // No effect unless `allows_rsvps` is true.
  optional uint32 max_attendees = 3;
}

message EventInstance {
  string id = 1;
  string event_id = 2;
  optional Post post = 3;
  EventInstanceInfo info = 4;
  google.protobuf.Timestamp starts_at = 5;
  google.protobuf.Timestamp ends_at = 6;
  optional Location location = 7;
}

// To be used for ticketing, RSVPs, etc.
// Stored as JSON in the database.
message EventInstanceInfo {
  optional EventInstanceRsvpInfo rsvp_info = 1;
}

message EventInstanceRsvpInfo {
  // Overrides `EventInfo.allows_rsvps`, if set, for this instance.
  optional bool allows_rsvps = 1;
  // Overrides `EventInfo.allows_anonymous_rsvps`, if set, for this instance.
  optional bool allows_anonymous_rsvps = 2;

  
  optional uint32 max_attendees = 3;

  optional uint32 going_rsvps = 4;
  optional uint32 going_attendees = 5;

  optional uint32 interested_rsvps = 6;
  optional uint32 interested_attendees = 7;

  optional uint32 invited_rsvps = 8;
  optional uint32 invited_attendees = 9;
}

// EventInstance attendance statuses. State transitions may generally happen
// in any direction, but:
// * `REQUESTED` can only be selected if another user invited the user whose attendance is being described.
// * `GOING` and `NOT_GOING` cannot be selected if the EventInstance has ended (end time is in the past).
// * `WENT` and `DID_NOT_GO` cannot be selected if the EventInstance has not started (start time is in the future).
// `INTERESTED` and `REQUESTED` can apply regardless of whether an event has started or ended.
enum AttendanceStatus {
  // The user is (or was) interested in attending. This is the default status.
  INTERESTED = 0;
  // Another user has invited the user to the event.
  REQUESTED = 1;
  // The user plans to go to the event, or went to the event.
  GOING = 2;
  // The user does not plan to go to the event, or did not go to the event.
  NOT_GOING = 3;
}

message GetEventAttendancesRequest {
  string event_instance_id = 1;
  optional string anonymous_attendee_auth_token = 2;
}

message EventAttendances {
  repeated EventAttendance attendances = 1;
}

// Could be called an "RSVP." Describes the attendance of a user at an `EventInstance`. Such as:
// * A user's RSVP to an `EventInstance` (one of `INTERESTED`, `REQUESTED` (i.e. invited), `GOING`, `NOT_GOING`).
// * Invitation status of a user to an `EventInstance`.
// * `ContactMethod`-driven management for anonymous RSVPs to an `EventInstance`.
message EventAttendance {
  // Unique server-generated ID for the attendance.
  string id = 1;
  // ID of the `EventInstance` the attendance is for.
  string event_instance_id = 2;

  oneof attendee {
    // If the attendance is non-anonymous, core data about the user.
    UserAttendee user_attendee = 3;
    // If the attendance is anonymous, core data about the anonymous attendee.
    AnonymousAttendee anonymous_attendee = 4;
  }
  // Number of guests including the RSVPing user. (Minimum 1).
  uint32 number_of_guests = 5;
  // The user's RSVP to an `EventInstance` (one of `INTERESTED`, `REQUESTED` (i.e. invited), `GOING`, `NOT_GOING`)
  AttendanceStatus status = 6;
  // User who invited the attendee. (Not yet used.)
  optional string inviting_user_id = 7;
  // Public note for everyone who can see the event to see.
  string private_note = 8;
  // Private note for the event owner.
  string public_note = 9;
  Moderation moderation = 10;
  google.protobuf.Timestamp created_at = 11;
  optional google.protobuf.Timestamp updated_at = 12;
}

// An anonymous internet user who has RSVP'd to an `EventInstance`.
//
// (TODO:) The visibility on `AnonymousAttendee` `ContactMethod`s should support the `LIMITED` visibility, which will
// make them visible to the event creator.
message AnonymousAttendee {
  // A name for the anonymous user. For instance, "Bob Gomez" or "The guy on your front porch."
  string name = 1;
  // Contact methods for anonymous attendees. Currently not linked to Contact methods for users.
  repeated ContactMethod contact_methods = 2;
  // Used to allow anonymous users to RSVP to an event. Generated by the server
  // when an event attendance is upserted for the first time. Subsequent attendance
  // upserts, with the same event_instance_id and anonymous_attendee.auth_token,
  // will update existing anonymous attendance records. Invalid auth tokens used during upserts will always create a new `EventAttendance`.
  optional string auth_token = 3;
}


// Wire-identical to [Author](#author), but with a different name to avoid confusion.
message UserAttendee {
  string user_id = 1;
  optional string username = 2;
  optional MediaReference avatar = 3;
}